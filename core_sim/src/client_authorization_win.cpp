// Copyright (C) Microsoft Corporation. All rights reserved.

#ifdef _WIN32

#include <WinSock2.h>
#include <Windows.h>
#include <bcrypt.h>
#include <ncrypt.h>
#include <stdio.h>
#include <time.h>
#include <wincrypt.h>

#include <codecvt>
#include <string>
#include <vector>

#ifdef max
#undef max
#undef min
#endif  // max

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)

#ifndef STATUS_INVALID_SIGNATURE
#define STATUS_INVALID_SIGNATURE ((NTSTATUS)0xC000A000L)
#endif  // STATUS_INVALID_SIGNATURE

namespace microsoft {
namespace projectairsim {

// Client authorization handle implementation for Linux
class ImplWin : public ClientAuthorization::Impl {
 public:
  ImplWin(void);
  ~ImplWin();

  virtual bool SetPublicKey(const char* sz, size_t cch) override;
  virtual uint64_t SetToken(const char* sz, size_t cch) override;

 protected:
  virtual std::string GetAuthorizationTokenPublicKey(void) override;

 private:
  typedef std::vector<BYTE> VecB;  // Vector of bytes

 private:
  int Base64Decode(const char* pchBase64, size_t cchBase64, VecB* pvecRet);
  int Base64Encode(const VecB& vecb, std::string* pstrRet);
  int ConvertSignatureFromRFC3279ToIEEEP1363(BCRYPT_KEY_HANDLE bcryptkeyhandle,
                                             const VecB& vecSignatureRFC3279,
                                             VecB* pvecSignatureP1363Ret);
  int CreateMessageHash(VecB vecbMessage, VecB* pvecbHashRet);
  NTSTATUS VerifyECDsaSignature(const VecB& vecbMessage,
                                const VecB& vecbSignatureRFC3279,
                                const VecB vecbASN1PublicKeyInfo);

 private:
  BCRYPT_KEY_HANDLE bcrypt_key_handle_token_transport_;  // Encryption key for
                                                         // transporting token
  bool is_little_endian_;  // True if running on architecture with little-endian
                           // integers
  VecB vecb_ecdsa_public_key_;  // ECDsa public key
};                              // class ImplWin

ImplWin::ImplWin(void)
    : ClientAuthorization::Impl(),
      bcrypt_key_handle_token_transport_(INVALID_HANDLE_VALUE),
      is_little_endian_(htons(0x1234) == 0x3412),
      vecb_ecdsa_public_key_() {}

ImplWin::~ImplWin() {
  if (bcrypt_key_handle_token_transport_ != INVALID_HANDLE_VALUE)
    BCryptDestroyKey(bcrypt_key_handle_token_transport_);
}

int ImplWin::Base64Decode(const char* szBase64, size_t cchBase64,
                          VecB* pvecRet) {
  DWORD cb = 0;

  if (!CryptStringToBinaryA(szBase64, static_cast<DWORD>(cchBase64),
                            CRYPT_STRING_BASE64, NULL, &cb, NULL, NULL)) {
    return (GetLastError());
  }

  pvecRet->resize(cb);

  if (!CryptStringToBinaryA(szBase64, static_cast<DWORD>(strlen(szBase64)),
                            CRYPT_STRING_BASE64, pvecRet->data(), &cb, NULL,
                            NULL)) {
    return (GetLastError());
  }

  return (0);
}

int ImplWin::Base64Encode(const VecB& vecb, std::string* pstrRet) {
  DWORD cch = 0;

  if (!CryptBinaryToStringA(vecb.data(), vecb.size(),
                            CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF, NULL,
                            &cch)) {
    return (GetLastError());
  }

  pstrRet->resize(cch);

  if (!CryptBinaryToStringA(vecb.data(), vecb.size(),
                            CRYPT_STRING_BASE64 | CRYPT_STRING_NOCRLF,
                            pstrRet->data(), &cch)) {
    return (GetLastError());
  }

  return (0);
}

int ImplWin::ConvertSignatureFromRFC3279ToIEEEP1363(
    BCRYPT_KEY_HANDLE bcryptkeyhandle, const VecB& vecSignatureRFC3279,
    VecB* pvecSignatureP1363Ret) {
  // ECC parameter struct missing from system headers
  typedef struct {
    ULONG dwVersion;                  // Version of the structure
    ECC_CURVE_TYPE_ENUM dwCurveType;  // Supported curve types.
    ECC_CURVE_ALG_ID_ENUM
    dwCurveGenerationAlgId;  // For X.592 verification purposes, if we
                             // include Seed we will need to include the
                             // algorithm ID.
    ULONG cbFieldLength;     // Byte length of the fields P, A, B, X, Y.
    ULONG cbSubgroupOrder;   // Byte length of the subgroup.
    ULONG cbCofactor;        // Byte length of cofactor of G in E.
    ULONG cbSeed;  // Byte length of the seed used to generate the curve.
    // P[cbFieldLength]              Prime specifying the base field.
    // A[cbFieldLength]              Coefficient A of the equation y^2 = x^3 +
    // A*x + B mod p B[cbFieldLength]              Coefficient B of the equation
    // y^2 = x^3 + A*x + B mod p Gx[cbFieldLength]             X-coordinate of
    // the base point. Gy[cbFieldLength]             Y-coordinate of the base
    // point. n[cbSubgroupOrder]            Order of the group generated by G =
    // (x,y) h[cbCofactor]                 Cofactor of G in E. S[cbSeed] Seed of
    // the curve.
  } BCRYPT_ECC_PARAMETERS_BLOB;

  DWORD cbSubgroupOrder;
  DWORD cbT = 0;
  NTSTATUS ntstatus = 0;
  CERT_ECC_SIGNATURE* pces;
  VecB vecIEEE;

  // Get ECC group order--the length of the r and s parameters each must be
  // equal to the subgroup length (OpenSSL uses field length, but the standard
  // specifies subgroup length)
  {
    VecB vecECCParameters;

    if (!NT_SUCCESS(ntstatus = BCryptGetProperty(bcryptkeyhandle,
                                                 BCRYPT_ECC_PARAMETERS, nullptr,
                                                 0, &cbT, 0))) {
      char sz[128];

      sprintf_s(sz, "BCryptGetProperty() returned error 0x%08x", ntstatus);
      throw std::runtime_error(sz);
    }
    vecECCParameters.resize(cbT);
    if (!NT_SUCCESS(ntstatus = BCryptGetProperty(
                        bcryptkeyhandle, BCRYPT_ECC_PARAMETERS,
                        vecECCParameters.data(), (ULONG)vecECCParameters.size(),
                        &cbT, 0))) {
      char sz[128];

      sprintf_s(sz, "BCryptGetProperty() returned error 0x%08x", ntstatus);
      throw std::runtime_error(sz);
    }

    // Get ECC group order--the length of the r and s parameters each must be
    // equal to the group order (OpenSSL uses field size, but the standard
    // specifies group order)
    cbSubgroupOrder =
        reinterpret_cast<BCRYPT_ECC_PARAMETERS_BLOB*>(vecECCParameters.data())
            ->cbSubgroupOrder;
  }

  // Convert from RFC3279 DER-formatted signature to ECC signature structure
  if (!CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                           X509_ECC_SIGNATURE, vecSignatureRFC3279.data(),
                           static_cast<DWORD>(vecSignatureRFC3279.size()),
                           CRYPT_DECODE_ALLOC_FLAG, NULL, &pces, &cbT)) {
    char sz[128];

    ntstatus = GetLastError();
    sprintf_s(sz, "CryptDecodeObjectEx() for public key failed error 0x%08x",
              ntstatus);
    throw std::runtime_error(sz);
  }

  // Copy data from ECC signature to IEEE signature structure
  if ((pces->r.cbData > cbSubgroupOrder) ||
      (pces->s.cbData > cbSubgroupOrder)) {
    // The ECC r or s value in the signature have too many bytes to to be
    // handled by the key's cryptographical algorithm.
    ntstatus = STATUS_INVALID_PARAMETER;
    logger_.LogError(str_component_name_,
                     "ECC signature not valid for the key's algorithm");
    goto LError;
  } else {
    VecB::iterator itDst;

    pvecSignatureP1363Ret->resize(2 * static_cast<size_t>(cbSubgroupOrder));
    if (is_little_endian_) {
      // The ECC signature structure is little endian while IEEE P1363 structure
      // is big endian
      itDst =
          pvecSignatureP1363Ret->begin() +
          (cbSubgroupOrder -
           pces->r.cbData);  // If necessary, insert MSB zeros so that the
                             // integer parameter has the correct byte length
      for (auto *pb = pces->r.pbData + pces->r.cbData - 1,
                *pbFirst = pces->r.pbData;
           pb >= pbFirst; --pb, ++itDst)
        *itDst = *pb;

      itDst +=
          (cbSubgroupOrder -
           pces->s.cbData);  // If necessary, insert MSB zeros so that the
                             // integer parameter has the correct byte length
      for (auto *pb = pces->s.pbData + pces->s.cbData - 1,
                *pbFirst = pces->s.pbData;
           pb >= pbFirst; --pb, ++itDst)
        *itDst = *pb;
    } else {
      // The ECC signature structure is big endian like the IEEE P1363 structure
      itDst =
          pvecSignatureP1363Ret->begin() +
          (cbSubgroupOrder -
           pces->r.cbData);  // If necessary, insert MSB zeros so that the
                             // integer parameter has the correct byte length
      for (auto *pb = pces->r.pbData, *pbEnd = pces->r.pbData + pces->r.cbData;
           pb < pbEnd; ++pb, ++itDst)
        *itDst = *pb;

      itDst +=
          (cbSubgroupOrder -
           pces->s.cbData);  // If necessary, insert MSB zeros so that the
                             // integer parameter has the correct byte length
      for (auto *pb = pces->s.pbData, *pbEnd = pces->s.pbData + pces->s.cbData;
           pb < pbEnd; ++pb, ++itDst)
        *itDst = *pb;
    }
  }

LError:
  return (ntstatus);
}

int ImplWin::CreateMessageHash(VecB vecbMessage, VecB* pvecbHashRet) {
  NTSTATUS ntstatus = 0;
  DWORD cb = 0;
  DWORD cbT = 0;
  BCRYPT_ALG_HANDLE bcryptalghandleHash = NULL;
  BCRYPT_HASH_HANDLE bcrypthashhandle = NULL;
  VecB vecHashObject;

  // Open the hash algorithm provider
  if (!NT_SUCCESS(
          ntstatus = BCryptOpenAlgorithmProvider(
              &bcryptalghandleHash, BCRYPT_SHA512_ALGORITHM, NULL, 0))) {
    char sz[128];

    sprintf_s(sz, "BCryptOpenAlgorithmProvider() returned error 0x%08x",
              ntstatus);
    throw std::runtime_error(sz);
  }

  // Allocate buffer for the hash object
  if (!NT_SUCCESS(ntstatus = BCryptGetProperty(bcryptalghandleHash,
                                               BCRYPT_OBJECT_LENGTH, (PBYTE)&cb,
                                               sizeof(cb), &cbT, 0))) {
    char sz[128];

    sprintf_s(
        sz, "BCryptGetProperty() for hash object length returned error 0x%08x",
        ntstatus);
    throw std::runtime_error(sz);
  }

  vecHashObject.resize(cb);

  // Allocate buffer for the hash of the message
  {
    DWORD cbHash = 0;

    if (!NT_SUCCESS(ntstatus = BCryptGetProperty(
                        bcryptalghandleHash, BCRYPT_HASH_LENGTH, (PBYTE)&cbHash,
                        sizeof(cbHash), &cbT, 0))) {
      char sz[128];

      sprintf_s(
          sz,
          "BCryptGetProperty() for hash buffer length returned error 0x%08x",
          ntstatus);
      throw std::runtime_error(sz);
    }

    pvecbHashRet->resize(cbHash);
  }

  // Create the hash of the message
  if (!NT_SUCCESS(ntstatus = BCryptCreateHash(
                      bcryptalghandleHash, &bcrypthashhandle,
                      static_cast<PUCHAR>(vecHashObject.data()),
                      static_cast<DWORD>(vecHashObject.size()), NULL, 0, 0))) {
    char sz[128];

    sprintf_s(sz, "BCryptCreateHash() returned error 0x%08x", ntstatus);
    throw std::runtime_error(sz);
  }

  if (!NT_SUCCESS(ntstatus = BCryptHashData(
                      bcrypthashhandle, static_cast<PUCHAR>(vecbMessage.data()),
                      static_cast<DWORD>(vecbMessage.size()), 0))) {
    char sz[128];

    sprintf_s(sz, "BCryptHashData() returned error 0x%08x", ntstatus);
    throw std::runtime_error(sz);
  }

  if (!NT_SUCCESS(ntstatus = BCryptFinishHash(
                      bcrypthashhandle,
                      static_cast<PUCHAR>(pvecbHashRet->data()),
                      static_cast<DWORD>(pvecbHashRet->size()), 0))) {
    char sz[128];

    sprintf_s(sz, "BCryptFinishHash() returned error 0x%08x", ntstatus);
    throw std::runtime_error(sz);
  }

LError:
  if (bcrypthashhandle) BCryptDestroyHash(bcrypthashhandle);
  if (bcryptalghandleHash) BCryptCloseAlgorithmProvider(bcryptalghandleHash, 0);

  return (ntstatus);
}

std::string ImplWin::GetAuthorizationTokenPublicKey(void) {
  // Generate token encryption key pair if needed
  if (bcrypt_key_handle_token_transport_ == INVALID_HANDLE_VALUE) {
    BCRYPT_ALG_HANDLE bcrypt_alg_handle;
    const BCRYPT_RSAKEY_BLOB* pbcrypt_rsakey_blob;
    VecB vecb_key_openssh_public;
    VecB vecb_rsakey_binary;

    // Create the key pair
    if (!NT_SUCCESS(BCryptOpenAlgorithmProvider(
            &bcrypt_alg_handle, BCRYPT_RSA_ALGORITHM, NULL, 0))) {
      throw std::logic_error("BCryptOpenAlgorithmProvider() failed");
    }
    if (!NT_SUCCESS(BCryptGenerateKeyPair(
            bcrypt_alg_handle, &bcrypt_key_handle_token_transport_,
            ClientAuthorization::TokenV1::kRSAKeySizeTokenTransport, 0))) {
      throw std::logic_error("BCryptGenerateKeyPair() failed");
    }
    if (!NT_SUCCESS(
            BCryptFinalizeKeyPair(bcrypt_key_handle_token_transport_, 0))) {
      throw std::logic_error("BCryptFinalizeKeyPair() failed");
    }

    // Get the public key
    {
      DWORD cb;

      if (!NT_SUCCESS(BCryptExportKey(bcrypt_key_handle_token_transport_, 0,
                                      BCRYPT_RSAPUBLIC_BLOB, nullptr, 0, &cb,
                                      0))) {
        throw std::logic_error(
            "BCryptExportKey() failed while determining blob size");
      }
      vecb_rsakey_binary.resize(cb);
      if (!NT_SUCCESS(BCryptExportKey(
              bcrypt_key_handle_token_transport_, 0, BCRYPT_RSAPUBLIC_BLOB,
              vecb_rsakey_binary.data(), vecb_rsakey_binary.size(), &cb, 0))) {
        throw std::logic_error("BCryptExportKey() failed while getting blob");
      }
      pbcrypt_rsakey_blob = reinterpret_cast<const BCRYPT_RSAKEY_BLOB*>(
          vecb_rsakey_binary.data());
    }

    // Convert the public key to OpenSSH format
    {
      static const char* sz_algorithm = "ssh-rsa";

      auto cb_algorithm = strlen(sz_algorithm);
      bool fInsertLeadingZero = false;
      VecB::iterator it;
      auto pb_rsakey_data = reinterpret_cast<const BYTE*>(pbcrypt_rsakey_blob) +
                            sizeof(*pbcrypt_rsakey_blob);
      uint32_t ui32;

      // OpenSSH public key is an algorithm string ("ssh-rsa"), the public
      // exponent (big-endian), the modulus (big-endian), and the 4-byte
      // integer byte length for each of them (big-endian).
      size_t cb_key_public = 3 * sizeof(uint32_t) + cb_algorithm +
                             pbcrypt_rsakey_blob->cbPublicExp +
                             pbcrypt_rsakey_blob->cbModulus;

      auto pb_exponent = pb_rsakey_data;
      auto pb_modulus = pb_exponent + pbcrypt_rsakey_blob->cbPublicExp;

      // If exponent or modulus most-significant byte is 0x80 or greater,
      // we must insert a leading zero so the unsigned integer won't be
      // interpreted as negative.
      if (*pb_exponent >= 0x80) ++cb_key_public;
      if (*pb_modulus >= 0x80) ++cb_key_public;

      // Size the public key buffer
      vecb_key_openssh_public.resize(cb_key_public);
      it = vecb_key_openssh_public.begin();

      // Add algorithm string length-data pair
      ui32 = htonl(cb_algorithm);
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, &ui32, sizeof(ui32));
      it += sizeof(ui32);
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, sz_algorithm,
               cb_algorithm);
      it += cb_algorithm;

      // Add RSA exponent length-data pair
      fInsertLeadingZero = (*pb_exponent >= 0x80);
      ui32 = htonl(pbcrypt_rsakey_blob->cbPublicExp +
                   (fInsertLeadingZero ? 1 : 0));
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, &ui32, sizeof(ui32));
      it += sizeof(ui32);
      if (fInsertLeadingZero) *it++ = 0;
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, pb_exponent,
               pbcrypt_rsakey_blob->cbPublicExp);
      it += pbcrypt_rsakey_blob->cbPublicExp;

      // Add RSA modulus length-data pair
      fInsertLeadingZero = (*pb_modulus >= 0x80);
      ui32 =
          htonl(pbcrypt_rsakey_blob->cbModulus + (fInsertLeadingZero ? 1 : 0));
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, &ui32, sizeof(ui32));
      it += sizeof(ui32);
      if (fInsertLeadingZero) *it++ = 0;
      memcpy_s(&*it, vecb_key_openssh_public.end() - it, pb_modulus,
               pbcrypt_rsakey_blob->cbModulus);
    }

    // Store the public key base-64 encoded
    {
      std::string str_base64;

      if (Base64Encode(vecb_key_openssh_public, &str_base64) != 0)
        throw std::logic_error("Base64Encode() failed");
      str_base64_token_encryption_public_key_ = "ssh-rsa " + str_base64;
    }
  }

  return (str_base64_token_encryption_public_key_);
}

bool ImplWin::SetPublicKey(const char* sz, size_t cch) {
  __super::SetPublicKey(sz, cch);
  if (cch == 0) {
    vecb_ecdsa_public_key_.clear();
    logger_.LogVerbose(str_component_name_,
                       "Client authorization public key cleared--all clients "
                       "accepted and authorization tokens not required");
    return (true);
  } else {
    bool fOK = (Base64Decode(sz, cch, &vecb_ecdsa_public_key_) == 0);

    if (fOK)
      logger_.LogVerbose(str_component_name_,
                         "Client authorization public key set--all clients "
                         "required to present authorization token");
    else
      logger_.LogError(str_component_name_,
                       "Failed to set client authorization public key");

    return (fOK);
  }
}

uint64_t ImplWin::SetToken(const char* sz, size_t cch) {
  uint64_t timestamp_expiration;
  ClientAuthorization::TokenV1 tokenv1;
  VecB vecb_token;

  // If we don't have a valid public key, return a timestamp reflecting the
  // current expiration point
  if (vecb_ecdsa_public_key_.empty()) {
    if (time_point_when_expired_ == kTimePointAlwaysAuthorized) {
      logger_.LogVerbose(str_component_name_,
                         "Client authorization token accepted (no client "
                         "authorization token public key)");
      return (ClientAuthorization::TokenV1::kTimestampExpirationNone);
    } else {
      logger_.LogVerbose(str_component_name_,
                         "Client authorization token rejected (invalid client "
                         "authorization token public key)");
      return (0);
    }
  }

  // If no token given, clear the client authorization
  if (cch == 0) {
    time_point_when_expired_ = kTimePointNotAuthorized;
    logger_.LogVerbose(str_component_name_, "Client authorization removed");
    return (0);
  }

  if (bcrypt_key_handle_token_transport_ == INVALID_HANDLE_VALUE) {
    logger_.LogError(str_component_name_, "No token transport encryption key");
    throw std::invalid_argument("token is not valid");
  }

  // Decrypt the token
  {
    BCRYPT_OAEP_PADDING_INFO bopi = {0};
    DWORD cb;
    VecB vecb_encrypted;
    VecB vecb_token_base64;

    // Get the binary ciphertext
    if (Base64Decode(sz, cch, &vecb_encrypted) != 0) {
      logger_.LogError(
          str_component_name_,
          "Client authorization token could not be base-64 decoded");
      throw std::invalid_argument("token is not valid");
    }

    // Decode the ciphertext
    bopi.pszAlgId = BCRYPT_SHA1_ALGORITHM;
    if (!NT_SUCCESS(
            BCryptDecrypt(bcrypt_key_handle_token_transport_,
                          reinterpret_cast<PUCHAR>(vecb_encrypted.data()),
                          vecb_encrypted.size(), &bopi, nullptr, 0, nullptr, 0,
                          &cb, BCRYPT_PAD_OAEP))) {
      logger_.LogError(str_component_name_,
                       "Client authorization token could not be decrypted");
      throw std::runtime_error("encrypted token is not valid");
    }
    vecb_token_base64.resize(cb);
    if (!NT_SUCCESS(
            BCryptDecrypt(bcrypt_key_handle_token_transport_,
                          reinterpret_cast<PUCHAR>(vecb_encrypted.data()),
                          vecb_encrypted.size(), &bopi, nullptr, 0,
                          static_cast<PUCHAR>(vecb_token_base64.data()),
                          vecb_token_base64.size(), &cb, BCRYPT_PAD_OAEP))) {
      logger_.LogError(str_component_name_,
                       "Client authorization token could not be decrypted");
      throw std::runtime_error("encrypted token is not valid");
    }

    // Get the binary token data
    if (Base64Decode(reinterpret_cast<char*>(vecb_token_base64.data()),
                     vecb_token_base64.size(), &vecb_token) != 0) {
      logger_.LogError(str_component_name_,
                       "Client authorization token after decryption could not "
                       "be base-64 decoded");
      throw std::invalid_argument("token is not valid");
    }
  }

  // Get the token data and verify the signature
  {
    auto it = vecb_token.begin();

    // Get the token data
    tokenv1.version = *it++;
    if ((vecb_token.end() - it) < sizeof(tokenv1.timestamp_expiration)) {
      logger_.LogError(str_component_name_,
                       "Client authorization token is too short");
      throw std::length_error("signature is too short");
    }

    memcpy_s(&tokenv1.timestamp_expiration,
             sizeof(tokenv1.timestamp_expiration), &*it,
             sizeof(tokenv1.timestamp_expiration));
    it += sizeof(tokenv1.timestamp_expiration);

    // Verify we support the token version
    if (tokenv1.version != 1) {
      logger_.LogError(str_component_name_,
                       "Client authorization token version %d is not supported",
                       tokenv1.version);
      throw std::invalid_argument("token version is not supported");
    }

    // Verify the signature
    if (!NT_SUCCESS(VerifyECDsaSignature(VecB(vecb_token.begin(), it),
                                         VecB(it, vecb_token.end()),
                                         vecb_ecdsa_public_key_))) {
      logger_.LogError(str_component_name_,
                       "Client authorization token signature does not verify");
      throw std::invalid_argument("token is not valid");
    }
  }

  // Get the timestamp, converting from big-endian to platform's byte order
  memcpy_s(&timestamp_expiration, sizeof(timestamp_expiration),
           &tokenv1.timestamp_expiration, sizeof(tokenv1.timestamp_expiration));
  timestamp_expiration = htonll(timestamp_expiration);

  // Convert the timestamp to a time point and save
  time_point_when_expired_ =
      kTimePointEpochStart + std::chrono::seconds(timestamp_expiration);

  {
    char sz[128];
    std::time_t time_expiration =
        std::chrono::system_clock::to_time_t(time_point_when_expired_);
    std::tm tm = *std::gmtime(&time_expiration);

    std::strftime(sz, sizeof(sz), "%c", &tm);
    logger_.LogVerbose(
        str_component_name_,
        "Client authorization token accepted--client authorized until %s UTC",
        sz);
  }

  return (timestamp_expiration);
}

NTSTATUS ImplWin::VerifyECDsaSignature(const VecB& vecbMessage,
                                       const VecB& vecbSignatureRFC3279,
                                       const VecB vecbASN1PublicKeyInfo) {
  NTSTATUS ntstatus = 0;
  BCRYPT_KEY_HANDLE bcryptkeyhandlePublic = NULL;
  VecB vecHash;

  // Hash the plain text message
  if (!NT_SUCCESS(ntstatus = CreateMessageHash(vecbMessage, &vecHash))) {
    char sz[128];

    sprintf_s(sz, "CreateMessageHash() returned error 0x%08x", ntstatus);
    throw std::runtime_error(sz);
  }

  // Get the public key
  {
    DWORD cbCPKI = 0;
    CERT_PUBLIC_KEY_INFO* pcpki = nullptr;

    // Decode the public key info from ASN.1 encoding
    if (!CryptDecodeObjectEx(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                             X509_PUBLIC_KEY_INFO, vecbASN1PublicKeyInfo.data(),
                             static_cast<DWORD>(vecbASN1PublicKeyInfo.size()),
                             CRYPT_DECODE_ALLOC_FLAG, NULL, &pcpki, &cbCPKI)) {
      ntstatus = GetLastError();
      logger_.LogError(
          str_component_name_,
          "CryptDecodeObjectEx() for public key failed error 0x%08x",
          GetLastError());
      goto LError;
    }

    // Import the public key from the public key info
    if (!CryptImportPublicKeyInfoEx2(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                     pcpki, 0, 0, &bcryptkeyhandlePublic)) {
      ntstatus = GetLastError();
      logger_.LogError(
          str_component_name_,
          "CryptImportPublicKeyInfoEx2() for public key failed error 0x%08x",
          GetLastError());
      goto LError;
    }
  }

  // Verify the signature
  {
    VecB vecSignatureIEEEP1363;

    // Convert from RFC3279 DER-formatted signature to IEEE P1363
    if (!NT_SUCCESS(ntstatus = ConvertSignatureFromRFC3279ToIEEEP1363(
                        bcryptkeyhandlePublic, vecbSignatureRFC3279,
                        &vecSignatureIEEEP1363))) {
      logger_.LogError(
          str_component_name_,
          "ConvertSignatureFromRFC3279ToIEEEP1363() failed error 0x%08x",
          ntstatus);
      goto LError;
    }

    if (!NT_SUCCESS(ntstatus = BCryptVerifySignature(
                        bcryptkeyhandlePublic, nullptr,
                        static_cast<PUCHAR>(vecHash.data()),
                        static_cast<DWORD>(vecHash.size()),
                        static_cast<PUCHAR>(vecSignatureIEEEP1363.data()),
                        static_cast<DWORD>(vecSignatureIEEEP1363.size()), 0))) {
      if (ntstatus != STATUS_INVALID_SIGNATURE)
        logger_.LogError(str_component_name_,
                         "BCryptVerifySignature() returned error 0x%08x",
                         ntstatus);
      goto LError;
    }
  }

LError:
  if (bcryptkeyhandlePublic) BCryptDestroyKey(bcryptkeyhandlePublic);

  return (ntstatus);
}

}  // namespace projectairsim
}  // namespace microsoft

#endif  //_WIN32
